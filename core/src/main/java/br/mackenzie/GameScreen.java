package br.mackenzie;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.ScreenUtils;
import com.badlogic.gdx.utils.viewport.FitViewport;

public class GameScreen implements Screen{
    private final Main game;

    public GameScreen(Main game) {
        // Pega o SpriteBatch compartilhado com as outas classes
        this.game = game;
        this.spriteBatch = game.spriteBatch; 
    }
    // Tela
    SpriteBatch spriteBatch;
    FitViewport viewport;

    // Player
    Player player;
    
    // Animação (padrão)
    private Animation<TextureRegion> animacaoCorrida;
    private float stateTimeCorrida; 
    private TextureRegion frameAtual;
    private Texture[] playerTexturesToDispose; 

    // Animação (shield)
    private Animation<TextureRegion> animacaoShield;
    private float stateTimeShield; 
    private TextureRegion frameAtualShield;
    private Texture[] playerTexturesToDisposeShield;
    Texture playerTextureInitialShield;


    // Fases
    FaseBase fasePiscina;
    FaseBase faseAtual;

    // Inimigos
    private Texture boiaTexture;
    private Texture macarraoTexture;
    private Texture bolaTexture;
    private Array<Inimigo> inimigos;
    private float inimigoTimer;

    // Power-Ups
    //Pato
    private Texture patoTexture;
    private Texture patoTimerTexture;
    private Texture playerPatoTexture;
    private float patoTimer = 0f;
    private boolean patoAtivo = false;
    //Shield
    private Texture shieldTexture;
    private Texture shieldTimerTexture;
    private float shieldTimer = 0f;
    private boolean shieldAtivo = false;

    private Array<PowerUp> powerUps;
    private float powerUpTimer;
    //Extra
    private Texture patoShieldPlayerTexture;

    // Som 
    Sound patoSound;
    Sound shieldSound;
    Sound damageSound;

    // Pause
    private boolean paused;
    private Texture pauseButtonTexture;
    private Texture playButtonTexture;

    private final float x_pause = 0.15f;
    private final float y_pause = 4.69f;
    private final float width_pause = 0.25f;
    private final float height_pause = 0.23f;

    // UI
    private Stage uiStage;
    private BitmapFont fonte; // Fonte padrão
    private Texture menu_pause;

    // Barra de Progresso
    private Texture barraAzulClaroTexture;
    private Texture barraAzulEscuroTexture;
    private Texture IconePlayerTexture; 

    private float progressTime = 0f; // Tempo/Distância acumulada pelo player
    // Duração total da fase em "segundos de ação" (Ajuste este valor!)
    private final float MAX_PROGRESS_TIME = 60.0f; 
    
    @Override
    public void show() {
        // Inicializa tela
        spriteBatch = new SpriteBatch();
        viewport = new FitViewport(8, 5);

        // Inimigos
        boiaTexture = new Texture("Imagens_Fase1/Boia.png");
        macarraoTexture = new Texture("Imagens_Fase1/Macarrao.png");
        bolaTexture = new Texture("Imagens_Fase1/Bola.png");
        inimigos = new Array<>();
        
        // Power-ups
        //Pato
        patoTexture = new Texture("Imagens_Fase1/Pato.png");
        patoTimerTexture = new Texture("Imagens_Fase1/Imagens_UI/Pato_PU.png");
        playerPatoTexture = new Texture("Imagens_Personagem/Imagem_bonus_commit.png");
        //Shield
        shieldTexture = new Texture("Imagens_Fase1/EnergyShield.png");
        shieldTimerTexture = new Texture("Imagens_Fase1/Imagens_UI/Shield_PU.png");
        powerUps = new Array<>();
        //Extra
        patoShieldPlayerTexture = new Texture("Imagens_Fase1/Imagens_player_shield/Imagem_bonus_shield.png");

        // Som 
        patoSound = Gdx.audio.newSound(Gdx.files.internal("Sons_Fase1/PatoQuack.mp3"));
        shieldSound = Gdx.audio.newSound(Gdx.files.internal("Sons_Fase1/ShieldActivate.mp3"));
        damageSound = Gdx.audio.newSound(Gdx.files.internal("Sons_Fase1/damage.mp3"));

        // Pause
        pauseButtonTexture = new Texture("Imagens_Fase1/Imagens_UI/Pause_button.png");
        playButtonTexture = new Texture("Imagens_Fase1/Imagens_UI/Play_button.png");
        menu_pause = new Texture("Imagens_Fase1/Imagens_UI/Menu_fase.png");


        // Player
        //Carregamento dos frames nadador (padrão)
        TextureRegion[] framesNado = new TextureRegion[8];
        playerTexturesToDispose = new Texture[8]; //Array para liberar memória no dispose
        playerTexturesToDisposeShield = new Texture[8];

        //Carregamento dos frames nadador (shield)
        TextureRegion[] framesShield = new TextureRegion[8];
        
        for (int i = 0; i < 8; i++) {
            //Usando for para pegar as imagens do nadador
            Texture t1 = new Texture("Imagens_Personagem/Imagem_" + (i + 1) + "_commit.png");
            Texture t2 = new Texture("Imagens_Fase1/Imagens_player_shield/Imagem" + (i + 1) + "Shield.png");
            framesNado[i] = new TextureRegion(t1);
            framesShield[i] = new TextureRegion(t2);
            playerTexturesToDispose[i] = t1;
            playerTexturesToDisposeShield[i] = t2;
        }
        
        animacaoCorrida = new Animation<>(0.2f, framesNado); // 0.2s de duração por frame
        animacaoShield = new Animation<>(0.2f, framesShield);
        
        //Estado Inicial(padrão)
        stateTimeCorrida = 0f;
        frameAtual = animacaoCorrida.getKeyFrames()[0]; //Definir o primeiro frame como inicial

        //Estado Inicial(shield)
        stateTimeShield = 0f; 
        frameAtualShield = animacaoShield.getKeyFrames()[0];

        //Player configurado (padrão)
        Texture playerTextureInitial = playerTexturesToDispose[0];
        float playerWidth = 2f; 
        float playerHeight = playerWidth * (playerTextureInitial.getHeight() / (float) playerTextureInitial.getWidth());
        player = new Player(playerTextureInitial, -10f, 0.9f, playerWidth, playerHeight, viewport);

        // UI
        uiStage = new Stage();
        fonte = new BitmapFont();

        // Barra de Progresso
        barraAzulEscuroTexture = new Texture("Imagens_Fase1/Barra_de_progresso/barra_azul_escuro.png"); 
        barraAzulClaroTexture = new Texture("Imagens_Fase1/Barra_de_progresso/barra_azul_claro.png");
        IconePlayerTexture = new Texture("Imagens_Fase1/Barra_de_progresso/player_barra.png");

        progressTime = 0f;

        // Fase
        fasePiscina = new FasePiscina(this);
        faseAtual = fasePiscina;
        faseAtual.music.play();

    }

    @Override
    public void resize(int width, int height) {
        viewport.update(width, height, true);
        uiStage.getViewport().update(width, height, true);
    }

    @Override
    public void render(float dt) {
        dt = Gdx.graphics.getDeltaTime();
        inputsDoSistema();

        if(!paused){
            updateGameObjects(dt);
            colisoes();
            spawnInimigos(dt);
            spawnPowerUps(dt);

            // Controle dos timers dos power-ups
            if (patoTimer > 0) {
                patoTimer -= dt;
                if (patoTimer <= 0) {
                    patoAtivo = false;
                    player.clearPowerUpSprite();
                    faseAtual.setParalaxVelocity(0.75f);
                }
            }

            if (shieldTimer > 0) {
                shieldTimer -= dt;
                if (shieldTimer <= 0) {
                    shieldAtivo = false; // perde imunidade
                }
            }
        }
        drawGameObjects();
        drawUI();

        if (paused) {

            float uiW = uiStage.getViewport().getWorldWidth();
            float uiH = uiStage.getViewport().getWorldHeight();

            final float Menu_Width = uiW * 0.30f;
            final float Menu_Height = Menu_Width * (menu_pause.getHeight() / (float) menu_pause.getWidth());

            float imageX = (uiW - Menu_Width) / 2;
            float imageY = (uiH - Menu_Height) / 2;

            spriteBatch.setProjectionMatrix(uiStage.getCamera().combined);
            spriteBatch.begin();
        
            spriteBatch.draw(menu_pause, imageX, imageY, Menu_Width, Menu_Height); 
            
            spriteBatch.end();

            float x_quit = 3.7f;
            float y_quit = 2.05f;
            float width_quit = 0.6f;
            float height_quit = 0.3f;

            float x_resume = 3.7f;
            float y_resume = 2.45f;
            float width_resume = 0.6f;
            float height_resume = 0.3f;


            // LÓGICA DE CLIQUE 
            if (com.badlogic.gdx.Gdx.input.justTouched()) {
                Vector2 touchPoint = new Vector2(com.badlogic.gdx.Gdx.input.getX(), com.badlogic.gdx.Gdx.input.getY());
                viewport.unproject(touchPoint); 

                float inputX = touchPoint.x;
                float inputY = touchPoint.y;

                // Verificação de clique no botão QUIT 
                if (inputX >= x_quit && inputX <= x_quit + width_quit &&
                    inputY >= y_quit && inputY <= y_quit + height_quit) {
                    
                    // Troca de tela para Menu de Fases
                    game.setScreen(new FasesScreen(game));
                }

                // Verificação de clique no botão RESUME 
                if (inputX >= x_resume && inputX <= x_resume + width_resume &&
                    inputY >= y_resume && inputY <= y_resume + height_resume) {
                    
                    // O jogo deixa de estar pausado
                    paused = !paused;
                    if(paused){
                        faseAtual.music.pause();
                    } else {
                        faseAtual.music.play();
                    }  
                }

                // Verificação de clique no botão de PAUSE 
                if (inputX >= x_pause && inputX <= x_pause + width_pause &&
                    inputY >= y_pause && inputY <= y_pause + height_pause) {
                    
                    // O jogo deixa de estar pausado
                    paused = !paused;
                    if(paused){
                        faseAtual.music.pause();
                    } else {
                        faseAtual.music.play();
                    }  
                }
            }
        }
    }

    private void updateGameObjects(float dt) {
        // Player
        //Atualiza O player 
        player.update(dt);

        // Lógica da Animação: Usa a variável de estado 'shieldAtivo' para escolher a animação
        if (shieldAtivo) { // Se o Shield estiver ativo, atualiza a animação do Shield
            if (player.isMoving()) {
                stateTimeShield += dt; // Atualiza o tempo do Shield
                frameAtualShield = animacaoShield.getKeyFrame(stateTimeShield, true); 
            } else {
                stateTimeShield = 0f;
                frameAtualShield = animacaoShield.getKeyFrames()[0];
            }
        } else { // Caso contrário (Shield inativo), atualiza a animação Padrão
            if (player.isMoving()) {
                stateTimeCorrida += dt;
                frameAtual = animacaoCorrida.getKeyFrame(stateTimeCorrida, true); 
            } else {
                //Se parado, mostra o frame inicial
                stateTimeCorrida = 0f;
                frameAtual = animacaoCorrida.getKeyFrame(stateTimeCorrida); 
            }
        }

        faseAtual.update();

        // Inimigos
        for (int i = inimigos.size - 1; i >= 0; i--) {
            Inimigo ini = inimigos.get(i);
            ini.update(dt);
            if (ini.getBounds().x < -ini.getBounds().width) {
                inimigos.removeIndex(i);
            }
        }

        // Power-Ups
        for (int i = powerUps.size - 1; i >= 0; i--) {
            PowerUp pu = powerUps.get(i);
            pu.update(dt);

            if (pu.getBounds().x < -pu.getBounds().width) {
                powerUps.removeIndex(i);
            }
        }
    }
    private void spawnInimigos(float dt){
        // Lógica inimigos

        inimigoTimer += dt;
        if (inimigoTimer > 1f) {
            inimigoTimer = 0;
            float worldWidth = viewport.getWorldWidth();

            Inimigo newInimigo = null;
            int chanceInimigo = MathUtils.random(0, 9);

            int slotY = MathUtils.random(0, 5); 
            float spawnY; 

            switch (slotY) {
                case 0:
                    spawnY = 1.7f; //Raia Alta
                    break;
                case 1:
                    spawnY = 0.9f; //Raia Média
                    break;
                default:
                    spawnY = 0.1f; //Raia Baixa
                    break;
            }

            switch (chanceInimigo) {
                case 0:
                    newInimigo = new Inimigo(boiaTexture, worldWidth, spawnY, 0.5f, 0.5f,this);
                    break;
                case 1:
                    newInimigo = new Inimigo(bolaTexture, worldWidth, spawnY, 0.5f, 0.5f,this);
                    break;
                case 2:
                    newInimigo = new Inimigo(macarraoTexture, worldWidth, spawnY, 0.5f, 0.5f,this);
                    break;
                default:
                    break;
            }
            if (newInimigo != null) {
                inimigos.add(newInimigo);
            }
        }
    }
    private void spawnPowerUps(float dt){
        // Lógica power-ups

        powerUpTimer += dt;
        if (powerUpTimer > 3f) { 
            powerUpTimer = 0;

            float worldWidth = viewport.getWorldWidth();
            float puWidth = 0.7f;
            float puHeight = puWidth * (patoTexture.getHeight() / (float) patoTexture.getWidth());

            PowerUp powerUp = null;
            int chancePowerUp = MathUtils.random(0, 2);
            float spawnY; 
            int slotY = MathUtils.random(0, 5);

            switch (slotY) {
                case 0:
                    spawnY = 1.7f; //Raia Alta
                    break;
                case 1:
                    spawnY = 0.9f; //Raia Média
                    break;
                default:
                    spawnY = 0.1f; //Raia Baixa
                    break;
            }

            switch (chancePowerUp) {
                case 0:
                    //float inimigoWidth = 2;
                    //float inimigoHeight = inimigoWidth * (boiaTexture.getHeight() / (float) boiaTexture.getWidth());
                    powerUp = new Speed(patoTexture, worldWidth, spawnY, puWidth, puHeight, patoSound,this);
                    break;
                case 1:
                    //float dropSmallWidth = 1;
                    //float dropSmallHeight = dropSmallWidth * (bolaTexture.getHeight() / (float) bolaTexture.getWidth());
                    powerUp = new Shield(shieldTexture, worldWidth, spawnY, puWidth, puHeight, shieldSound,this);
                    break;
            }
            if (powerUp != null) {
                powerUps.add(powerUp);
            }
        }
    }
    private void colisoes(){
        // Player vs Inimigos
        for (int i = inimigos.size - 1; i >= 0; i--) {
            Inimigo ini = inimigos.get(i);
            if (player.getBounds().overlaps(ini.getBounds())) {
                inimigos.removeIndex(i);
                damageSound.play();
                if(shieldAtivo){} 
                else{
                    // Lógica para remover corações, vidas
                }
            }
        }

        // Player vs Power-Ups
        for (int i = powerUps.size - 1; i >= 0; i--) {
            PowerUp pu = powerUps.get(i);
            if (pu.getBounds().x < -pu.getBounds().width) {
                powerUps.removeIndex(i);
                continue; 
            }

            if (player.getBounds().overlaps(pu.getBounds())) {
                if (pu instanceof Speed) {
                    patoTimer = 15f;
                    patoAtivo = true;
                    patoSound.play();
                    player.setPowerUpSprite(playerPatoTexture);
                    faseAtual.setParalaxVelocity(1.5f);

                    // Dura 15 segundos
                } else if (pu instanceof Shield) {
                    shieldAtivo = true;  // nave fica imune
                    shieldTimer = 15f;  // 15 segundos de duração
                    //!!!!!!!!Som quando pega o Shield!!!!!!!!!!!!!
                    player.setPowerUpSprite(playerTextureInitialShield);
                }
                powerUps.removeIndex(i);
            }
        }
    }
    

    private void drawGameObjects() {
        ScreenUtils.clear(Color.BLACK);
        viewport.apply();
        spriteBatch.setProjectionMatrix(viewport.getCamera().combined);

        spriteBatch.begin();
    
        float worldWidth = viewport.getWorldWidth();
        float worldHeight = viewport.getWorldHeight();
        
        // Desenho Paralaxe Fundo
        float x1 = faseAtual.backgroundOffsetX % worldWidth;
        if (x1 > 0){
            x1 -= worldWidth; // Garante a rolagem contínua 

        }

        spriteBatch.draw(faseAtual.background, x1, 0, worldWidth, worldHeight); 
        spriteBatch.draw(faseAtual.background, x1 + worldWidth, 0, worldWidth, worldHeight);
        

        if (patoAtivo && shieldAtivo) { 
            spriteBatch.draw(patoShieldPlayerTexture, player.getX(), player.getY(), player.getWidth(), player.getHeight());
        } 
        else if (shieldAtivo) {
            spriteBatch.draw(frameAtualShield, player.getX(), player.getY(), player.getWidth(), player.getHeight());
        } 
        else if (patoAtivo) { 
            spriteBatch.draw(player.getPowerUpSprite(), player.getX(), player.getY(), player.getWidth(), player.getHeight());
        } 
        else { 
            spriteBatch.draw(frameAtual, player.getX(), player.getY(), player.getWidth(), player.getHeight());
        }
        

        for (Inimigo ini : inimigos) {
            ini.draw(spriteBatch);
        }

        for(PowerUp powerUp : powerUps){
            powerUp.draw(spriteBatch);
        }

        spriteBatch.end();
    }

    private void drawUI() {
        uiStage.act();
        uiStage.draw();

        // Pega tamanho do "mundo" do UI Stage
        float uiWidth = uiStage.getViewport().getWorldWidth();
        float uiHeight = uiStage.getViewport().getWorldHeight();

        spriteBatch.setProjectionMatrix(uiStage.getCamera().combined);

        spriteBatch.begin();

        // Dimensões dos ícones de power-up
        final float Icone_Width = 130f;
        final float Icone_Height = 80f;
        final float Padding = 10f;
        final float Spacing_H = 5f; 

        // Posição Y é a mesma para ambos
        float y = uiHeight - Icone_Height - Padding;

        // Posição X dos slots
        float xSlotDireita = uiWidth - Icone_Width - Padding;
        float xSlotEsquerda = xSlotDireita - Icone_Width - Spacing_H;


        // 1. Verifica se ambos estão ativos
        if (patoTimer > 0 && shieldTimer > 0) {
            
            // Pato 
            spriteBatch.draw(patoTimerTexture, xSlotDireita, y, Icone_Width, Icone_Height);
            String timeTextPato = "" + (int) patoTimer;
            fonte.draw(spriteBatch, timeTextPato, xSlotDireita + Icone_Width / 2f, y - 5f, 0, Align.center, false);

            // Shield 
            spriteBatch.draw(shieldTimerTexture, xSlotEsquerda, y, Icone_Width, Icone_Height);
            String timeTextShield = "" + (int) shieldTimer;
            fonte.draw(spriteBatch, timeTextShield, xSlotEsquerda + Icone_Width / 2f, y - 5f, 0, Align.center, false);

        // 2. Verifica se apenas o Pato está ativo 
        } else if (patoTimer > 0) {
            
            // Pato 
            spriteBatch.draw(patoTimerTexture, xSlotDireita, y, Icone_Width, Icone_Height);
            String timeTextPato = "" + (int) patoTimer;
            fonte.draw(spriteBatch, timeTextPato, xSlotDireita + Icone_Width / 2f, y - 5f, 0, Align.center, false);

        // Verifica se apenas o Shield está ativo
        } else if (shieldTimer > 0) {
            
            // Shield 
            spriteBatch.draw(shieldTimerTexture, xSlotDireita, y, Icone_Width, Icone_Height);
            String timeTextShield = "" + (int) shieldTimer;
            fonte.draw(spriteBatch, timeTextShield, xSlotDireita + Icone_Width / 2f, y - 5f, 0, Align.center, false);
        }

        // Desenho do Botão de Pause com coordenadas de UI
        final float Pause_Width = 130f; // Tamanho em pixels (ajuste se necessário)
        final float Pause_Height = 85f;
        final float Pause_Padding = 1f;

        // Coordenadas em pixels para o canto superior esquerdo
        float pauseX = Pause_Padding; 
        float pauseY = uiHeight - Pause_Height - Pause_Padding;

        Texture currentButtonTexture = paused ? playButtonTexture : pauseButtonTexture;

        spriteBatch.draw(currentButtonTexture, pauseX, pauseY, Pause_Width, Pause_Height);

        spriteBatch.end();
    }

    @Override
    public void dispose() { 
    
        for (Texture t : playerTexturesToDispose) {
            if (t != null) {
                t.dispose();
            }
        }
        for (Texture t : playerTexturesToDisposeShield) {
            if (t != null) {
                t.dispose();
            }
        }
        boiaTexture.dispose();
        macarraoTexture.dispose();
        bolaTexture.dispose();
        patoTexture.dispose();
        patoTimerTexture.dispose();
        playerPatoTexture.dispose();
        shieldTexture.dispose();
        shieldTimerTexture.dispose();
        pauseButtonTexture.dispose();
        playButtonTexture.dispose();
        patoSound.dispose();
        shieldSound.dispose();
        damageSound.dispose();
        fonte.dispose();
        faseAtual.dispose();
    }

    @Override public void pause() { }
    @Override public void resume() { }
    @Override public void hide() { faseAtual.music.pause(); }

    private void inputsDoSistema(){
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            paused = !paused;
            if(paused){
                faseAtual.music.pause();
            } else {
                faseAtual.music.play();
            }
        }
    }
}
